Inception:
What is CDN?  
What is crossorigin?
-------------------------------------------------------------------------------------------
React JS - 
Facebook is the creator of React JS
React is the JS library which helps us to build single page application with easy UI.
As REACT is a library it can work independently that means it can be applied to small portion of page like headers, footers, some other tags.
In Frameworks you have to create Whole app and cannot add it to the piece of code.
React JS was developed to manipulate the DOM using the JS. and react gives us the ways to do it.
Costliest operations in any application is DOM manipulation and when we do it whole DOM tree changes by udpating the nodes.
React comes in a picture to optimize this costliest operation by giving some advantages.
-------------------------------------------------------------------------------------------
To create an element in React we have to use the syntax as 
React.createElement() - basically the createElement create/returns the object
Now, this createElement takes 3 arguments.
1. element name
2. object - attributes to the element
3. content in that element
It also has props which are children that goes to the HTML element.

render - render method is responsible to convert the createElement object into HTML element that browser understands.

To create a root in react we use the syntax as 
ReactDOM.createRoot(document.getElementById("root"));
Ex: 
const heading = React.createElement("h1", {}, "Hello World from React"); //{} - is a place where you give the attributes to the element.
const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(heading);

If we want to give multiple elements in parent createElement as childs the we have to wrap them into an array.
const container = React.createElement("div", { id: "container" }, [
  React.createElement("div", { id: "child1" }, [
    React.createElement("h1", { id: "heading1" }, "Hello world 1!"),
    React.createElement(
      "h2",
      { id: "subHeading1" },
      "Welcome to React JS world 1!"
    ),
  ]),
  React.createElement("div", { id: "child2" }, [
    React.createElement("h1", { id: "heading2" }, "Hello world 2!"),
    React.createElement(
      "h2",
      { id: "subHeading2" },
      "Welcome to React JS world 2!"
    ),
  ]),
]);
const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(container);

So, to overcome the pain/difficulty of creating the multiple nested elements using the createElement we use JSX which simplifies our HTML code.

If you add some HTML code under root and then create the new elements using react the HTML code under root. then, the root will be replaced by the elements created by the REACT.
-------------------------------------------------------------------------------------------
Steps to make our simple application as React application.
1. initialize the npm.
2. Install React and React DOM
3. Install the Parcel
4. Once installation for the 2 & 3 are done we have the node_modules folder, package.json and package-lock.json files gets created.
package.json -  It is created when we initialize the npm and has all the dependencies with versions(this has ^ or ~) that are required to create and run react application
package-lock.json - It has the actual exact versions that are being installed for all the dependencies.
node_modules - It is a container which has all the packages and projects that are required to run the application.
5. When we run the npx parcel index.html dist and parcel-cache folders are created
dist folder - It generates the development build and gives the local server host that can run in the browser. This is like development mode in local
parcel-cache - It is a file generated to maintain the cache and helps to re-render the applciation faster.
6. Update the attribute value type="module" to the script so that react understands that the script is not the browser script but the local script.
7. import the React and ReactDOM in script folder to make the JS file reactive.

NPM - 
It is everything other than Node Package Manager.
NPM does not have any full form. but, it manage packages as a package manager.
NPM is standard repository for all the packages. it keeps track of what versions needs to install in the system.

npm init - created the depependency that are logged in the package.json file.
once we do npm init, a package.json file is created. 
This package.json is the configuration for the npm.

npm install -D parcel:
Parcel - A Beast!!
There are two types of dependency that we can install. one is the dev dependency and other is the normal dependency.
A dev dependency means it is required with the development environment.
Now, parcel is installed and added the dev dependencies in package.json. Also,node_modules and package-lock.json will be created.
"devDependencies": {
    "parcel": "^2.16.3" 
  }
// ^caret - If we use this in app the dependency will be updated to the latest versions available automatically, 
// ~tilde - This will install major versions automatically.

package-lock.json: Keeps the track of exact versions that is being installed for all the dependencies.

node_modules: 
It contains all the code and dependecy files that we fetched from NPM.
Why do we have so many files other that parcel in the node_modules?
Transitive dependencies: 
Parcel as a project has its own dependencies
Now, those dependencies can have there own dependencies again 
and this is known as transitive dependencies

if we have package.json and package-lock.json. we can create our node_modules again whenever required. just by doing npm install.

-----------------------------------------------------------------------------
npm install react
npm install react-dom
this will install the React into our project. now update the attribute "type" in app.js so that react will understand that the script is normal script than the browser script 
this will also help to add imports and use react elements in app.js

dist folder - when you run npx build index.html. it generates the development build of your project and hosted to local server.

browsersList - Powerful tool to configure the app and that can be used and run on the browsers across the world.
-------------------------------------------------------------------------------------------
Adding scripts to run the application: Update the scripts in the package.json
"start": "parcel index.html"
"build": "parcel build index.html"
this helps to run our application using the command "npm start". We cannot use same npm build to create prod ready. use "npm run build".

When react was build the core to create elements were using React.createElement and ReactDOM.createRoot. 
So, Facebook developers has created JSX which is different from React. we can write React code without JSX also.
The only reason to introduce JSX is to make the coding easy.

JSX - JavaScript extension is a convention to merger JS and HTML together. and it is a syntatic sugar similar to HTML/XML and we can write the JS code in this file.
It is not HTML in JS.
  ex: const createHeader = React.createElement(
        "h1",
        { id: "heading" },
        "Namaste React with React Element"
      );
      const heading2 = <h1 id="heading">Namaste React with JSX Element</h1>; //this is not pure JS code because JS engine cannot understand JSX. JS understands only the Ecma script language.
      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(heading2);
The base is like the JSX code converted to React.createElement(). Then it creates an JS object and renders as HTML. babel again comes into picture to convert this.
heading2 - This is how we create elements in JSX. Now, JSX provides the object jsxHeading which need to be rendered to HTML.
this is not pure JS code because JS engine cannot understand JSX. 
JS understands only the Ecma script language.
Parcel helps to transpile the heading2 before it reaches to JS engine. which means the code is converted in a way that react and browsers can understand.
Parcel it self not transpiles the code. it will sends the code to babel which will transpile the code.
babel - is a JS compiler. Its job to convert the code to JS code.
If we want to give attributes it should be in the camelCase.
If we have multiple elements added we need to wrap them in brackets(). because, babel needs to understand the start and end of elements that are considered as tokens and then converted to React code.


React component - Everything is a component in the React application. It is a basic building block of the react applications.
They are two types:
1. Class based components: Is an old way to write the code.
2. Functional components: 
New/Latest standards used to create react application. 
uses functions to create components which is just a JS function.
use first word in Uppercase and pascalCase while creating the function components. because JSX treats the lowercase names as built-in dom tags.
It returns the JSX element.
we can run any piece of JS code within the {} within the JSX code.
A react element is a variable in React JS application 
element can be used inside the {}, which can be again be used with in the React Element or React Component
and React componen can be used with <ComponentName /> in other React Element or React Component.

Component composition - Components inside other component is called component composition

cross side scripting - Using the JS code within our application. To steal cookies or sessions.
JSX takes care to handle this and skips the malicious codes that was being sent as API response or any other data.
So, basically JSX sanitizes the code before it is rendered.
-------------------------------------------------------------------------------------------
props - In React props are passed from component to component. when you want to send dynamic data to components we use props. props is a JS object.
Config Driven UI - A website is driven by configuration. Controls the UI using config and this config comes from backend.
cloudinary - It is a CDN where all the image are hosted.

best practices to write code-
*Destructure the prop value for the object that is passed to component. use optional chaining.
*Loop the component to load components - reusability(Map, filter and reduce function or for)
*Loops always returns some JSX
*Unique key prop - Each time we use a loop we have to send a unique key as a prop.
  key is reserved. Always add a key prop.
  why?
  Let say we have card container and has many restaurant card childrens. Now react optimizes render cycle when it have same level of components.
  There should be a unique id for each restaurant card. If you dont give id, react will never know which restaurant card is new and re-render all card.
  If we give a unique Id. React will understands that component with Id at any position like start or end or inbetween
  when we use a map we need to add a key. and never use index as keys.

Why React?
It makes the development easy. by providing some super powers.

Best practice is to make seperate files for seperate components.

src- Is like a source code which industries follows.

.js and .jsx - for JS or JSX files. and tsx for TS.

There are two types of export and import - 
Default:
export default ComponentName;
import Component from '/Path';
Named:
export const ComponentName;
import {ComponentName} from '/Path';

Can I use Default and Named export?
Yes.

React - It is faster for efficient DOM manipulations.because it has a virtual DOM.

Hooks: Hooks in React are normal JS functions. Written by Facebook developer.
To use them we have to import the Hooks. The most important hooks in React are useState and useEffect.
useState - Helps to create a state variable. This will keep the UI intact with the Data layer.
When ever state variable updates, React re-render the component.

Reconciliation - 
It is also known as React Fiber(React 16 - A new Algorithm was introduced which is known as React Fiber).
When the UI loads on screen React creates a virtual DOM of the application which is not the actual DOM
Virtual DOM is representation of actual DOM. It is a Javascript object of React Component.

Diffing Algorithm - 
Whenever a state variable is updated. React tracks the changes and, 
This will find the difference between updated Virtual DOM and Actual Virtual DOM. 
Then it will update the Actual DOM for every render cycle.


Monolithic application - A monolithic application is a single, self-contained software unit where all components (UI, business logic, data access) 
are tightly coupled and run as one large process, making it simple to develop and deploy initially but challenging to 
scale, update, or maintain as it grows complex, often contrasting with microservices. 
It's like one big block of code, where changing one small part requires recompiling and redeploying the entire application, leading to potential single points of failure. 

Micro services - These services includes of BE, UI, Auth, DB, SMS, E-mail
This is known as seperations of concerns and a single responsibility application.
React application can be treated as UI micro service.

The services are connected by running on their specific ports. All the services are used by a API call.


Approaches to fetch Data from BE: 
1. When app loads then make an API call, fetch the data and render the UI.
load -> API -> render

2. As soon as page loads we will render the UI. Now, an API call is made and re-render the data
load -> render -> API -> re-render.

In React, we always use the second approach. And this gives the better UX.
Re-render cycle for react is very fast. So, we have to not bother about rendering twice.

useEffect:
useEffect is a normal JS function and it has two arguments.
  1. A callback function and
  2. A dependency array
This is called after the component renders.


CORS policy: Browsers block us to call one origin from another origin.

CORS - Cross Origin Resource Sharing
A CORS is a mechanism which uses additional HTTP headers to tell the browser. whether, a specific web app can share a resource from other web app.
Both web apps should have different origin.
How resource sharing between two applications works.
Before any call from one application to other application is made. There a preflight option is checked and adds additional HTTPS headers along with the headers.
Additional http headers - [Access-control-allow-origin/methods:*]
No, all calls need not be go with preflight call.
To resolve the error we can set the header from the server. We have browser plugins.

shimmer UI: Loads a UI replica as skeleton before actual data loads on the screen.


const [btnName, setBtnName] = useState("Login"); - How can a const value is changed. when it is declared as const?
Because when a value is changed using the useState the component is re-rendered and the value will be the new value to the stack.

useEffect(()=>{},[]) - It is definitely called after initial render after the component is rendered fully.
 1. Without dependecy array [] useEffect is called on every component render.
 2. If the dependecy array is empty, useEffect is called on only initial render and just once.
 3. If the dependecy array has some value. then, useEffect will called everytime when the dependency changes.

useState() - const [value, setValue] = useState("").
useState helps us to create the local state variable in the component and  whenever the state of the variable changes component re-renders.
This should always be used and declared and called inside the functional component only.
Call the useStates always on the top.
Never create the state variables in the if, else conditions or in for loops or in functions.
-----------------------------------------------------------------------------------
Routing:
Routing - Allows navigation between different pages based on the URL path.
There are two types of routing in the web applications.
1. client side routing
2. sever side routing

Dynamic routing - 
Dynamic routing allows us to define routes with dynamic parameters so that the same component can be reused for multiple URLs.
It is commonly used for:
Product details
Hotel details
User profiles
Booking IDs
{ path: "/restaurants/:resId", element: <RestaurantMenu /> }, :resId is dynamic


Route - React Router is a client-side routing library that allows navigation between different components based on the URL path, without reloading the page.
It helps build Single Page Applications (SPA).
To use routes in React we have to install the Route library using "npm install react-router-dom"
To create routes we need go to app.js and add them as app.js in root level component for react application.
  1. Now, create the routing configuration. by importing Browser route as
      import { createBrowserRouter,RouterProvider } from "react-router-dom";
  2. create routing configurations in app router. This tells browser router what should happen when and where to route.
      const appRouter = createBrowserRouter([
        { path: "/", element: <AppLayout /> }, //path tells what is the path to be used in browser, element tells which component should it show.
        { path: "/about", element: <About /> },
      ]);
  3. Now, we need to provide this configuration using the RouterProvider.
      root.render(<RouterProvider router={appRouter} />);
  4. If we pass any random paths and try to access the URL react-router-dom handles this case and throws the error page with details(404).
     To create our own error page. we can add path with error component.
     { path: "/", element: <AppLayout />, errorElement: <Error /> }
  5. react-router-dom also provides a hook named useRouterError this will gives the more information about the error.
     import { useRouteError } from "react-router";
     const Error = () => {
        const err = useRouteError();
        console.log(err);
        return (
          <div>
            <h1>
              {err.statusText} - error status: {err.status}
            </h1>
            <h2>{err.data}</h2>
          </div>
        );
      };
  6. We can also create the children routes in React. This will help us to keep header and footer intact, when we want to load mulitple components in the body.
    {/* if path is / then load <Body /> else load relevent components based on path. this can be achived using the Outlet */}
    import { createBrowserRouter, RouterProvider, Outlet } from "react-router-dom";
    const AppLayout = () => {
      return (
        <div className="appName">
          <Header />
          {/* if path is / then load <Body /> else load relevent components based on path. this can be achived using the Outlet */}
          <Outlet /> // Outlet fills the component based on the childrens path
        </div>
      );
    };
    const appRouter = createBrowserRouter([
    {
      path: "/",
      element: <AppLayout />,
      children: [
        { path: "/", element: <Body /> },
        { path: "/about-us", element: <About /> },
        { path: "/contact-us", element: <Contact /> },
      ],
      errorElement: <Error />,
    },
    ]);
    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<RouterProvider router={appRouter} />);
    *In HTML the filled out components by Outlet loaded when we check the elements in browser*
  7. use Link provided by react-router-dom which works same as <a>. here "to" attribute add path using to attribute for navigation


-----------------------------------------------------------------------------
Class components:
Class components - In react class base components are created using the below syntax
import React from 'react';
class UserClass extends React.component{ // We use React.component is class that is given by react which tells that this is a class component.
  render(){ // Render method will return the JSX 
  return(
    <div></div>
  )

  }
}
To load class components in web page we need to have the instance for that class.

Props: Props are immutable values that are passed to the components. they are passed normally to class component
But, to extract props in a class component we need to use the constructor and super method.
constructor will create instance for the component state and 
super will create the instance for the react class components. so, that props can be used in the react component.
ex: constructor(props){
      super(props)
    }

useState() in class component: We can create a state variables inside the constructor. using the this.state. we do not have useState in class components.
ex: this.state = {
      count: 0,
      count2: 1,//multiple state variables.
    };

To update the state - never update state variables directly. You can update using this.setState({count:this.state.count+1})

Life cycle of class based component:
When class based component is loaded in the UI, Now the instance of the class is created.
When it component is instantiated or loaded the constructor is called first in the class based components.
once the constructor is called the the render is called and returns the JSX.
At last the componentDidMount() Method is called.

If we have a parent class component and the lifecycle will be triggered as
Parent constructor called first,
then parent rended is called. Now, we have child component in parent render so, at next
Child constructor called,
then child render method is called,
then child componentDidMount method is called and at last
the parent componentDidMount method is called.

if we have multiple childs then,
-Parent constructor called first,
-then parent rended is called. Now, we have child component in parent render so, at next
 -Child1 constructor called,
 -then child1 render method is called,
 -Child2 constructor called,
 -then child2 render method is called, // for child1 and 2 React will batch in the render phase so, componentDidMount for both loads next after this rendering.
  -then child1 componentDidMount method is called //same batching is done for componentDidMount to.
  -then child2 componentDidMount method is called and at last
-the parent componentDidMount method is called.
Why batching is done by react?
As DOM manipulation is the expensive operation. So react batches the multiple render and commit phases for multiple components to optimize and load it fast to udpate the DOM
DOM manipulation begins before commit phase.

componentDidMount is another method given in the class component
componentDidMount(){
}
It is used to make API calls and handling the side effects.

Mounting
React lifecycle has two phases.
1. Render phase - has constructor, render
2. Commit phase - has component mounting,updating and unmounting

Updating
componentDidUpdate(){
  //this is called at last after componentDidMount
}

unmounting
componentWillUnmount(){
  
}

------------------------------------------------------------------------------
Optimization:

1. Modularity - 
Modularity means breaking down the code into multiple small modules and components. 
This is more maitainable and more testable.
Advantages:
  1. Resuable
  2. maintainable
  3. Testable
Signle responsibility is important while creating the app.

2. Custom hooks: Hooks are basically a JS utility functions. We can also create the custom hooks.
Why we need custom hook?
To avoid using the fetch data logic in component where we need to display data.
Instead create a custom hook handles the fetch api and make the API response available to other components
1. Add hooks always in util folder for more readablity.
2. Use the camleCase and "use"(library recommendation) keyword in starting to create custom hook. this will tell react this is custom hook and react understand this.
   ex: useRestaurantMenu.js

3. Chunking/code-splitting/dynamic-bundling/on-demand-loading/lazy-loading/dynami-import
    Load the page when only it required to be load on the web UI

-----------------------------------------------------------------------------
Adding CSS to Application
CSS / SASS / SCSS
Styled components
Bootstrap
Material UI
Tailwind CSS
Chakra UI
Ant Design
and many more frameworks and libraries which have prebuilt components that can used for UI

Let us integrate the tailwind CSS to our application.
Configure tailwind CSS into the project
1. install tailwind: npm install tailwindcss @tailwindcss/postcss postcss
   postcss - A tool for transforming CSS with JS. Tailwind uses postcss behind the screens
2. @import "tailwindcss"; - add this in the index.css
3. create postcss.config.js file in root level and add
   export default {
    plugins: {
      "@tailwindcss/postcss": {},
    }
  }
4. Add tailwind cli intellisense this will help in providing suggestions for tailwind classes



-----------------------------------------------------------------------------
Data is new oil:
Higher order components - It is function that takes a component and returns a function
Takes a component as input then add some enhancment to component and returns it back.

Important task of react application is to manage its data.
It has Two layers:
1. UI layer - consists of JSX
2. Data layer - consists of props & states

State lifting - "Lifting state up" in React is the process of moving shared state to the closest common ancestor 
                of the components that need it. 
                This pattern ensures a "single source of truth" for the data, 
                which makes it easier to synchronize, debug, and manage the state across multiple components. 
Basically lifting the state up defines to ontrol the state in parents than in children to provide some features
ex - showing the accordian data only which clicked

controlled and un-controlled component
If child component is controlled by parent component then the child component is called controlled component.

ex: 
RestaurantMenu.js
  const [showIndex, setShowIndex] = useState(null); //creating the index value that need to be shared to child component
          <RestaurantCategory
            key={category?.card?.card?.title}
            data={category?.card?.card}
            showList={index === showIndex ? true : false} // control the child component to show only what clicked.
            setShowIndex={() => setShowIndex(index)} // show component that clicked
          />
import { useState } from "react";
import ItemsList from "./ItemsList";

const RestaurantCategory = ({ data, showList, setShowIndex }) => {
  console.log(data);
  const itemCards = data.itemCards;
  return (
    <div className="shadow-sm  m-2 p-1 border-2 border-gray-200 rounded-md cursor-pointer">
      <div
        className="text-md flex items-center justify-between font-bold p-2"
        onClick={() => { 
          setShowIndex(); //calling the index value that need to be shown
        }}
      >
        <div>{data.title}</div>
        <div className="transition-all ease-in ">{showList ? "⬆️" : "⬇️"}</div>
      </div>
      {showList && (
        <div className="text-left">
          {itemCards.map((item) => (
            <ItemsList key={item.card.info.id} item={item.card.info} />
          ))}
        </div>
      )}
    </div>
  );
};
export default RestaurantCategory;

Props drilling - Passing data from one component to other component from parent to children to grand children is called props drilling

context API - 
Pre built in React
Resolves the props drilling issue and data can be accessed globally across any component.

---------------------------------------------------------------------------------
Redux - 
A predictable State container for JS app.
Redux team offers two libraries:
1. React-Redux
2. Redux Toolkit
Redux is a seperate library. We can install this and use it in React application.

Redux is not mandatory application. Redux comes into picture only when we have lot of data to trasfer through out the application.
Use Redux only when it is required.
We also have zustand library similar to redux.

Redux store - It is a big JS object and kept in a central global place.
Slice - It is a small portion of redux store. To store the all the data in smaller parts related to that level of components.
ex - cart, theme, loggedIn users
So when we click on add the items to cart it will dispatch the action. this action will call function and this will modify your cart.
Dispatch - will dispatch the action
Action - this will call a function
Selector - subscribing to the store

configureStore - comes from reduxjs/toolkit
Provider - comes from react-redux

We can wrap the redux provider only for what components we need to use redux.

To create a redux functionality
1. Install - npm i @reduxjs/toolkit and npm i react-redux
2. Create a store - Configure the slice in the store by adding the reducer with slice name.
3. Add the Provider to app with the store.
4. Create a Slice - This will have name, initialState and reducers. reducers again has actions. 
                    when we export this we have to export the reducer and actions that are used in reducer.
                    We will mutating the state here
5. Read the cart in the components - this can be done by subscribing the store using the selector
                                     selector is a hook in react, useSelector().
                                     this will give the access to the store.
                                     Always subscribe to the small portion of the store
In slice we have reducers
In store we have one reducer for whole app.
In vaniela  Redux(older redux) => Don't mutate the state.
  To update state create a newState with spreading actual state and return the newState.
In Redux-Toolkit - We can mutate the state. - This will again use same as older redux behind the scenes. 
  So, Immer library will help here.
  Immer takes redux code, compare and gives new code.
We can also return the items with empty object instead of setting the state.items.length = 0. to clear the items.
  This basically means either mutate the state or return the empty object as per RTK rule.
----------------------------------------------------------------------------------------------------------------------
Testing: There are two types of testing
1. Manual testing - checking parts of UI manually
2. Automated testing - Write a code that will test our components
#Developers Testing 
1. Unit testing: Testing the react components in isolation. This means testing the particular component.
2. Integration testing: Testing the integration of component. This means testing components which communicate with each other.
3. e2e testing: Testing the react application from landing to leaving the page. from login to do some flow to logout.

As a developer we are concerned with #1 Unit testing & #2 Integration testing.

Libraries to do testing.
1. React testing library - This will use Jest, A delightful JS testing frame work. React testing library uses jest in background.
   1. Install react testing library: npm install --save-dev @testing-library/react @testing-library/dom
   2. install jest: jest my-test --notify --config=config.json
   3. install babel dependencies: npm install --save-dev babel-jest @babel/core @babel/preset-env
   4. configure the babel: 
      module.exports = {
        presets: [
          ["@babel/preset-env", { targets: { node: "current" } }],
          ["@babel/preset-react", { runtime: "automatic" }],
        ],
      };
  5. configure parcel configuration to disable default babel transpilation. add .parcelrc file and add code from parcel site.
     to find .parcelrc. 
     go to https://parceljs.org/ 
     -> find JS in left side menu and click 
     -> find parcel in right side sub menu
     -> check for babel.config.json and .parcelrc and add configurations.
  6. Configure the Jest - npx create-jest, before that install npm install --save-dev @babel/preset-react(this will make JSX work in test cases)
  7. install jsdom library - npm install --save-dev jest-environment-jsdom
  8. install jest dom testing library - npm install @testing-library/jest-dom
Now, you can start writing the test cases.

To write the test case, 
1. create __tests__ - this will be tracked by jest to check the testing files that can be of specs/tests of .ts/.js files.
__tests__ = dunder tests/dunder methods(__tests__).
2. create your testing file.
   ex: sum.test.js
       This file has the test function with two parameters that is description and a callback function.
       import { sum } from "../sum";
       test("Sum function should calculate sum of two numbers", () => {
        const result = sum(3, 4); //call sum file
        //Assertion
        expect(result).toBe(7); // is not mandatory to write. but, always use assertion to check the test.
       });

Unit testing:
First render the component in the test function.
then, check for component elements like inputs, buttons, placeholders, etc...
Always the rendered component is the react element which is the virtual DOM.
