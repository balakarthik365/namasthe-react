When and why do we need lazy()?
We use React.lazy() to dynamically import components, so they are loaded only when required, instead of being part of the initial bundle.
This enables code splitting, improves initial load time, and optimizes performance for large applications.
Example:
const About = React.lazy(() => import("./About"));
lazy() creates a separate bundle, but Suspense does NOT create the bundle â€” the bundler does.

2ï¸âƒ£ What is Suspense?
Suspense is a React component that lets us handle loading states for components that suspend rendering (like lazy-loaded components or data fetching).
It does NOT create bundles â€” it:
Waits for the async component
Shows a fallback UI meanwhile
Example:
<Suspense fallback={<Shimmer />}>
  <About />
</Suspense>

3ï¸âƒ£ Why do we get this error about startTransition?
Error:
"A component suspended while responding to synchronous inputâ€¦"
Actual reason (important correction):

This happens when:
A lazy-loaded component suspends
During a high-priority synchronous update (like click, input, navigation)

React doesnâ€™t want to block the UI suddenly with a loading state.
How startTransition fixes it
import { startTransition } from "react";

startTransition(() => {
  setShowComponent(true);
});


âœ” Marks the update as non-urgent
âœ” Allows React to keep UI responsive
âœ” Suspense can safely show fallback

ğŸ“Œ Key point:

Suspense alone doesnâ€™t fix this â€” priority control using startTransition does.

4ï¸âƒ£ Advantages of Code Splitting (lazy + Suspense)
Correct advantages:
Smaller initial JS bundle
Faster First Contentful Paint
Better performance for large apps
Loads features only when needed

5ï¸âƒ£ Disadvantages of Code Splitting
Real disadvantages (interview-ready):
Too many small bundles â†’ network overhead
Lazy loading everywhere can cause UX delays
Needs proper fallback handling

Slightly more complex debugging
âŒ Your earlier disadvantage was incorrect
(â€œIf we donâ€™t use lazy, big bundle is createdâ€ â€” thatâ€™s not a disadvantage of the pattern)

6ï¸âƒ£ When and why do we need Suspense?
We use Suspense whenever a component may suspend rendering, such as:
React.lazy
Concurrent data fetching (future / libraries)
Streaming SSR
It provides a fallback UI until the async operation completes.
ğŸ”¥ Lead-Level One-Liner (Memorize This)

lazy() enables code splitting, Suspense handles loading states, and startTransition controls update priority to keep the UI responsive.